import { defineStore } from 'pinia'
import { useGoggleStore } from './goggle'
import { allGoggleHostStores } from './hosts'
import type { GoggleFile, GoggleFilePreview, GoggleFileHostHandle, GoggleFileHost } from 'src/types'

export const useGoggleFileStore = defineStore('goggleFile', {
  state: () => ({
    isLoading: false,
    error: undefined as Error | unknown | undefined,
    goggleFilePreviews: [] as GoggleFilePreview[],
    goggleFile: undefined as GoggleFile | undefined,
    /**
     * One pagination system managed for this store and all other hosts have to
     * implement it, we define a per page limit here and they fetch with this
     * limit based on the last fetched one, which they have to store in the
     * store for reference. When there is a list call here, we will pull the
     * hosts and append the complete list here.
     */
    pagination: {
      perPage: 10,
    },
  }),

  getters: {
    /**
     * Available hosts
     * Reduce objects to only those with `isAvailable` getter and turn the
     * creation function into a instance of the store.
     * We don' want to handle already instantiated stores here, cause of Cypress
     * component testing issues.
     * Return object with only those key/value pairs that are available
     */
    availableHosts(): Record<GoggleFileHostHandle, GoggleFileHost> {
      const out = []
      for (const [key, value] of Object.entries(allGoggleHostStores)) {
        const theHost = value()
        if (theHost.isAvailable) {
          out.push([key, theHost])
        }
      }
      return Object.fromEntries(out)
    },
    /**
     * Shortcut to get the current host out of the available hosts
     */
    host(): GoggleFileHost | undefined {
      if (!this.goggleFile) return
      return this.availableHosts[this.goggleFile.host]
    },
    /**
     * Go through all available hosts and see if the optional pagination.hasNextPage is true
     */
    hasNextPage() {
      return Object.values(this.availableHosts).some(
        (host) => host.pagination?.hasNextPage,
      )
    },
    /**
     * To avoid having to call the host store directly outside of this store,
     * use this getter
     */
    goggleStore() {
      return useGoggleStore()
    }
  },

  actions: {
    /**
     * Retrieve all goggle files from all hosts
     */
    async list() {
      try {
        this.isLoading = true
        this.error = undefined
        const goggleFilePreviews = await Promise.all(
          Object.values(this.availableHosts).map((host) =>
            host.list(this.pagination.perPage),
          ),
        )
        // append to existing previews
        this.goggleFilePreviews = [
          ...this.goggleFilePreviews,
          ...goggleFilePreviews.flat(),
        ]
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Retrieve a given goggle file from a given host
     * And set it as the current goggle file
     */
    async retrieve(host: GoggleFileHostHandle, id: string) {
      try {
        // Only retrieve the goggle file if it is not already loaded in the current store
        if (
          this.goggleFile &&
          this.goggleFile.host === host &&
          this.goggleFile.id === id
        ) {
          return
        }
        this.isLoading = true
        this.error = undefined
        this.goggleFile = await this.availableHosts[host].retrieve(id)
        if (!this.goggleFile) throw new Error('Goggle file not found')
        this.goggleStore.parse(this.goggleFile)
      } catch (error) {
        this.error = error
        this.goggleFile = undefined
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Create a new goggle file under the given host
     * And set the current goggle file to the newly created one
     */
    async create(host: GoggleFileHostHandle) {
      try {
        this.isLoading = true
        this.error = undefined
        this.goggleFile = await this.availableHosts[host].create(
          'Unnamed Goggle',
          '! This is the default template for a new Goggle created with Gearchy\n! You can edit the Goggle on https://app.gearchy.wolf.gdn',
        )
        if (!this.goggleFile) throw new Error('Goggle file not found')
        this.goggleStore.parse(this.goggleFile)
        this.resetPagination()
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Update the host file with the current state
     * Content of the updated goggle file is generated by goggle store
     */
    async update() {
      try {
        if (!this.goggleFile || !this.host) throw new Error('No goggle file')
        this.isLoading = false
        this.error = undefined
        this.goggleFile.content = this.goggleStore.stringifiedGoggle
        await this.availableHosts[this.host.hostInfo.handle].update(
          this.goggleFile,
        )
        this.resetPagination()
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Update the host file with the current state
     */
    async delete() {
      try {
        if (!this.goggleFile || !this.host) throw new Error('No goggle file')
        this.isLoading = false
        this.error = undefined
        await this.availableHosts[this.host.hostInfo.handle].delete(
          String(this.goggleFile.id),
        )
        this.goggleFile = undefined
        this.goggleStore.goggle = undefined
        this.resetPagination()
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Reset pagination for all hosts that implement the 'resetPagination' action
     */
    resetPagination() {
      this.goggleFilePreviews = []
      Object.values(this.availableHosts).forEach((host) => {
        if (typeof host.resetPagination === 'function') {
          host.resetPagination()
        }
      })
      this.list()
    },
  },
})
