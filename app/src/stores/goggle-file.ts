import { defineStore } from 'pinia'
import { useGoggleStore } from './goggle'
import { hosts } from 'src/stores/hosts'
import type { GoggleFile, GoggleFilePreview } from 'src/types'

const goggleStore = useGoggleStore()

export const useGoggleFileStore = defineStore('goggleFile', {
  state: () => ({
    isLoading: false,
    error: undefined as Error | unknown | undefined,
    goggleFilePreviews: [] as GoggleFilePreview[],
    goggleFile: undefined as GoggleFile | undefined,
    /**
     * One pagination system managed for this store and all other hosts have to
     * implement it, we define a per page limit here and they fetch with this
     * limit based on the last fetched one, which they have to store in the
     * store for reference. When there is a list call here, we will pull the
     * hosts and append the complete list here.
     */
    pagination: {
      perPage: 10,
    },
  }),

  getters: {
    /**
     * Available hosts
     * Filter objects with `isAvailable` getter
     * Return object with only those key/value pairs that are available
     */
    availableHosts() {
      return Object.fromEntries(
        Object.entries(hosts).filter(([, host]) => host.isAvailable),
      )
    },
    host() {
      if (!this.goggleFile) return undefined
      return this.availableHosts[this.goggleFile.host]
    },
    /**
     * Go through all available hosts and see if the optional pagination.hasNextPage is true
     */
    hasNextPage() {
      return Object.values(this.availableHosts).some(
        (host) => host.pagination?.hasNextPage,
      )
    },
  },

  actions: {
    /**
     * Retrieve all goggle files from all hosts
     */
    async list() {
      try {
        this.isLoading = true
        this.error = undefined
        const goggleFilePreviews = await Promise.all(
          Object.values(this.availableHosts).map((host) =>
            host.list(this.pagination.perPage),
          ),
        )
        // append to existing previews
        this.goggleFilePreviews = [
          ...this.goggleFilePreviews,
          ...goggleFilePreviews.flat(),
        ]
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Retrieve a given goggle file from a given host
     * And set it as the current goggle file
     */
    async retrieve(host: string, id: string) {
      try {
        // Only retrieve the goggle file if it is not already loaded in the current store
        if (
          this.goggleFile &&
          this.goggleFile.host === host &&
          this.goggleFile.id === id
        ) {
          return
        }
        this.isLoading = true
        this.error = undefined
        this.goggleFile = await this.availableHosts[host].retrieve(id)
        goggleStore.parse(this.goggleFile)
      } catch (error) {
        this.error = error
        this.goggleFile = undefined
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Create a new goggle file under the given host
     * And set the current goggle file to the newly created one
     */
    async create(host: string) {
      try {
        this.isLoading = true
        this.error = undefined
        this.goggleFile = await this.availableHosts[host].create(
          'Unnamed Goggle',
          '! This is the default template for a new Goggle created with Gearchy\n! You can edit the Goggle on https://app.gearchy.wolf.gdn',
        )
        goggleStore.parse(this.goggleFile)
        this.resetPagination()
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Update the host file with the current state
     * Content of the updated goggle file is generated by goggle store
     */
    async update() {
      try {
        if (!this.goggleFile || !this.host) throw new Error('No goggle file')
        this.isLoading = false
        this.error = undefined
        this.goggleFile.content = goggleStore.stringifiedGoggle
        await this.availableHosts[this.host.hostInfo.handle].update(
          this.goggleFile,
        )
        this.resetPagination()
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Update the host file with the current state
     */
    async delete() {
      try {
        if (!this.goggleFile || !this.host) throw new Error('No goggle file')
        this.isLoading = false
        this.error = undefined
        await this.availableHosts[this.host.hostInfo.handle].delete(
          this.goggleFile.id,
        )
        this.goggleFile = undefined
        goggleStore.goggle = undefined
        this.resetPagination()
      } catch (error) {
        this.error = error
      } finally {
        this.isLoading = false
      }
    },
    /**
     * Reset pagination for all hosts that implement the 'resetPagination' action
     */
    resetPagination() {
      this.goggleFilePreviews = []
      Object.values(this.availableHosts).forEach((host) => {
        if (typeof host.resetPagination === 'function') {
          host.resetPagination()
        }
      })
      this.list()
    },
  },
})
